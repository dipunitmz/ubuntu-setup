#!/bin/bash

# ============================================================================
# SCENARIO 1: INITIAL SETUP AND CONFIGURATION
# ============================================================================

# Set your global username and email
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"

# View all global configuration
git config --global --list

# Set default branch name to main
git config --global init.defaultBranch main

# Set default editor
git config --global core.editor "vim"

# Enable credential caching (15 min default)
git config --global credential.helper cache


# ============================================================================
# SCENARIO 2: CREATING A NEW LOCAL REPOSITORY AND PUSHING TO GITHUB
# ============================================================================

# Initialize a new Git repository
git init

# Add README and .gitignore files
touch README.md .gitignore

# Check repository status
git status

# Add specific file to staging area
git add README.md

# Add all files to staging area
git add .
git add -A

# Commit changes with message
git commit -m "Initial commit"

# Add remote repository (GitHub)
git remote add origin https://github.com/username/repo-name.git
git remote add origin git@github.com:username/repo-name.git

# Verify remote URL
git remote -v

# Push to remote repository (first time with -u)
git push -u origin main

# Push subsequent changes
git push


# ============================================================================
# SCENARIO 3: CLONING EXISTING REPOSITORY
# ============================================================================

# Clone public repository
git clone https://github.com/username/repo-name.git

# Clone private repository via SSH
git clone git@github.com:username/repo-name.git

# Clone specific branch
git clone -b branch-name https://github.com/username/repo-name.git

# Clone with custom directory name
git clone https://github.com/username/repo-name.git custom-folder-name


# ============================================================================
# SCENARIO 4: BASIC WORKFLOW - CHANGES, COMMITS, PUSH/PULL
# ============================================================================

# Check status of working directory
git status

# View differences in unstaged files
git diff

# View differences in staged files
git diff --staged
git diff --cached

# Add specific files
git add file1.txt file2.txt

# Add all modified and new files
git add .

# Add all files including deleted
git add -A

# Commit with message
git commit -m "Add feature X"

# Commit with detailed message
git commit -m "Title" -m "Detailed description"

# Add and commit in one command (tracked files only)
git commit -am "Update feature Y"

# Amend last commit (change message or add files)
git commit --amend -m "Updated commit message"

# Pull latest changes from remote
git pull

# Pull from specific branch
git pull origin main

# Fetch changes without merging
git fetch

# Fetch all remotes
git fetch --all

# Push changes to remote
git push

# Push to specific branch
git push origin branch-name

# Force push (use carefully)
git push -f
git push --force


# ============================================================================
# SCENARIO 5: BRANCH MANAGEMENT - CREATE, SWITCH, DELETE
# ============================================================================

# List all local branches
git branch

# List all branches (local and remote)
git branch -a

# List only remote branches
git branch -r

# Create new branch
git branch feature-branch

# Create and switch to new branch
git checkout -b feature-branch

# Switch to existing branch
git checkout feature-branch

# Switch to previous branch
git checkout -

# Rename current branch
git branch -m new-branch-name

# Rename any branch
git branch -m old-name new-name

# Delete local branch (safe)
git branch -d feature-branch

# Delete local branch (force)
git branch -D feature-branch

# Delete remote branch
git push origin --delete feature-branch
git push origin :feature-branch

# Push new local branch to remote
git push -u origin feature-branch

# Track remote branch locally
git checkout -b feature-branch origin/feature-branch
git checkout --track origin/feature-branch


# ============================================================================
# SCENARIO 6: MERGING BRANCHES
# ============================================================================

# Merge feature-branch into current branch
git merge feature-branch

# Merge with custom message
git merge feature-branch -m "Merge feature-branch into main"

# Merge without fast-forward (creates merge commit)
git merge --no-ff feature-branch

# Merge and squash commits
git merge --squash feature-branch

# Abort merge if conflicts occur
git merge --abort

# Preview changes before merging
git diff main..feature-branch


# ============================================================================
# SCENARIO 7: REBASING
# ============================================================================

# Rebase current branch onto main
git rebase main

# Rebase interactively (squash, edit, reorder commits)
git rebase -i HEAD~3
git rebase -i main

# Continue rebase after resolving conflicts
git rebase --continue

# Skip current commit during rebase
git rebase --skip

# Abort rebase and return to original state
git rebase --abort

# Pull with rebase instead of merge
git pull --rebase

# Rebase feature branch onto main
git checkout feature-branch
git rebase main


# ============================================================================
# SCENARIO 8: HANDLING MERGE CONFLICTS
# ============================================================================

# Check status during conflict
git status

# View conflicted files
git diff

# After manually resolving conflicts, add resolved files
git add resolved-file.txt

# Continue merge after resolving
git commit

# Continue rebase after resolving
git rebase --continue

# Abort merge
git merge --abort

# Use theirs version for conflicts
git checkout --theirs file.txt

# Use ours version for conflicts
git checkout --ours file.txt


# ============================================================================
# SCENARIO 9: STASHING CHANGES
# ============================================================================

# Stash uncommitted changes
git stash

# Stash with custom message
git stash save "Work in progress on feature X"

# List all stashes
git stash list

# Apply most recent stash and keep it
git stash apply

# Apply specific stash
git stash apply stash@{2}

# Apply most recent stash and remove it
git stash pop

# Apply specific stash and remove it
git stash pop stash@{1}

# Show stash contents
git stash show
git stash show -p

# Drop specific stash
git stash drop stash@{1}

# Clear all stashes
git stash clear

# Stash including untracked files
git stash -u
git stash --include-untracked


# ============================================================================
# SCENARIO 10: VIEWING HISTORY AND LOGS
# ============================================================================

# View commit history
git log

# View compact one-line log
git log --oneline

# View detailed log with diffs
git log -p

# View log with graph
git log --graph --oneline --all

# View last N commits
git log -5

# View commits by specific author
git log --author="Author Name"

# View commits in date range
git log --since="2 weeks ago"
git log --after="2024-01-01" --before="2024-12-31"

# View commits affecting specific file
git log -- file.txt
git log -p file.txt

# View commits with statistics
git log --stat

# View formatted log
git log --pretty=format:"%h - %an, %ar : %s"

# Show specific commit
git show commit-hash

# Show changes in last commit
git show HEAD


# ============================================================================
# SCENARIO 11: UNDOING CHANGES
# ============================================================================

# Discard changes in working directory
git checkout -- file.txt
git restore file.txt

# Unstage file (keep changes)
git reset HEAD file.txt
git restore --staged file.txt

# Undo last commit (keep changes staged)
git reset --soft HEAD~1

# Undo last commit (keep changes unstaged)
git reset HEAD~1
git reset --mixed HEAD~1

# Undo last commit (discard changes)
git reset --hard HEAD~1

# Revert specific commit (creates new commit)
git revert commit-hash

# Revert multiple commits
git revert commit-hash1 commit-hash2

# Discard all local changes
git reset --hard HEAD

# Remove untracked files
git clean -f

# Remove untracked files and directories
git clean -fd

# Preview what will be removed
git clean -n


# ============================================================================
# SCENARIO 12: CHERRY-PICKING
# ============================================================================

# Apply specific commit to current branch
git cherry-pick commit-hash

# Cherry-pick multiple commits
git cherry-pick commit-hash1 commit-hash2

# Cherry-pick range of commits
git cherry-pick commit-hash1..commit-hash5

# Continue cherry-pick after resolving conflicts
git cherry-pick --continue

# Abort cherry-pick
git cherry-pick --abort

# Cherry-pick without committing
git cherry-pick -n commit-hash
git cherry-pick --no-commit commit-hash


# ============================================================================
# SCENARIO 13: TAGGING
# ============================================================================

# List all tags
git tag

# Create lightweight tag
git tag v1.0.0

# Create annotated tag
git tag -a v1.0.0 -m "Version 1.0.0 release"

# Tag specific commit
git tag -a v1.0.0 commit-hash -m "Release version 1.0.0"

# Push specific tag to remote
git push origin v1.0.0

# Push all tags to remote
git push --tags
git push origin --tags

# Delete local tag
git tag -d v1.0.0

# Delete remote tag
git push origin --delete v1.0.0
git push origin :refs/tags/v1.0.0

# Checkout specific tag
git checkout v1.0.0


# ============================================================================
# SCENARIO 14: WORKING WITH REMOTES
# ============================================================================

# List remotes
git remote

# List remotes with URLs
git remote -v

# Add remote repository
git remote add upstream https://github.com/original/repo.git

# Change remote URL
git remote set-url origin git@github.com:username/repo.git

# Remove remote
git remote remove upstream
git remote rm upstream

# Rename remote
git remote rename origin new-origin

# Fetch from specific remote
git fetch upstream

# Merge remote branch into current branch
git merge upstream/main

# Sync fork with upstream
git fetch upstream
git checkout main
git merge upstream/main
git push origin main


# ============================================================================
# SCENARIO 15: SUBMODULES
# ============================================================================

# Add submodule
git submodule add https://github.com/user/repo.git path/to/submodule

# Initialize submodules after cloning
git submodule init
git submodule update

# Clone repository with submodules
git clone --recursive https://github.com/user/repo.git

# Update all submodules
git submodule update --remote

# Remove submodule
git submodule deinit path/to/submodule
git rm path/to/submodule
rm -rf .git/modules/path/to/submodule


# ============================================================================
# SCENARIO 16: ADVANCED OPERATIONS
# ============================================================================

# Find commits that introduced bugs (binary search)
git bisect start
git bisect bad
git bisect good commit-hash
git bisect reset

# Search commits for string
git log -S "search string"

# Search commit messages
git log --grep="bug fix"

# Show who modified each line of file
git blame file.txt

# Show who modified specific lines
git blame -L 10,20 file.txt

# Create patch file
git diff > changes.patch
git format-patch -1 commit-hash

# Apply patch
git apply changes.patch

# Create archive of repository
git archive --format=zip HEAD > repo.zip

# Show reflog (history of HEAD)
git reflog

# Recover deleted branch using reflog
git checkout -b recovered-branch commit-hash


# ============================================================================
# SCENARIO 17: WORKING WITH .GITIGNORE
# ============================================================================

# Create .gitignore file
touch .gitignore

# Stop tracking already tracked file
git rm --cached file.txt

# Stop tracking directory
git rm -r --cached directory/

# Update index after .gitignore changes
git rm -r --cached .
git add .
git commit -m "Update .gitignore"


# ============================================================================
# SCENARIO 18: INSPECTING AND COMPARING
# ============================================================================

# Compare working directory with staging area
git diff

# Compare staging area with last commit
git diff --cached
git diff --staged

# Compare two branches
git diff main..feature-branch

# Compare two commits
git diff commit1 commit2

# Compare specific file between branches
git diff main..feature-branch -- file.txt

# Show files changed between commits
git diff --name-only commit1 commit2

# Show statistics of changes
git diff --stat main..feature-branch


# ============================================================================
# SCENARIO 19: SQUASHING COMMITS
# ============================================================================

# Interactive rebase to squash last 3 commits
git rebase -i HEAD~3

# Squash all commits in feature branch
git checkout feature-branch
git rebase -i main

# Merge with squash
git merge --squash feature-branch
git commit -m "Squashed feature-branch"


# ============================================================================
# SCENARIO 20: COLLABORATION WORKFLOW
# ============================================================================

# Fork workflow: sync with upstream
git remote add upstream https://github.com/original/repo.git
git fetch upstream
git checkout main
git merge upstream/main
git push origin main

# Create feature branch
git checkout -b feature/new-feature

# Work on feature and push
git add .
git commit -m "Add new feature"
git push -u origin feature/new-feature

# Update feature branch with main
git checkout feature/new-feature
git fetch origin
git rebase origin/main
git push -f origin feature/new-feature

# After PR is merged, cleanup
git checkout main
git pull origin main
git branch -d feature/new-feature
git push origin --delete feature/new-feature


# ============================================================================
# SCENARIO 21: USEFUL ALIASES (ADD TO .gitconfig)
# ============================================================================

git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.unstage 'reset HEAD --'
git config --global alias.last 'log -1 HEAD'
git config --global alias.visual 'log --graph --oneline --all'
git config --global alias.amend 'commit --amend --no-edit'


# ============================================================================
# SCENARIO 22: SAFETY AND RECOVERY
# ============================================================================

# Create backup branch before risky operations
git branch backup-branch

# Recover lost commit using reflog
git reflog
git checkout -b recovery commit-hash

# Undo hard reset
git reflog
git reset --hard HEAD@{1}

# Show dangling commits
git fsck --lost-found

# Prune old reflog entries
git reflog expire --expire=30.days --all
git gc --prune=now

